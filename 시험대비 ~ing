시간복잡도 O(1)은 상수시간 O(n)은 선형시간
  배열: 접근 O(1) , 이외(탐색, 삽입, 삭제) O(n)
  링크드 리스트, 큐, 스택 : 접근, 탐색 O(n), 나머지 (삽입, 삭제) O(1)

링크드 리스트
  노드 : 데이터를 보관하는 필드와 다음 노드의 위치를 나타내는 포인터가 있음
  포인터 : 노드에서 다음 노드의 위치를 나타내는 데이터
  헤드 : 링크드 리스트의 첫번째 노드
  단일 링크드 리스트 : 각 요소에 다음 요소를 가리키는 포인터만 있는 링크드 리스트( 한방향으로만 이동 가능)
  이중 링크드 리스트 : 각 노드에 각각 다음 노드, 이전 노드를 가리키는 포인터가 모두 있어 어느 방향으로도 이동 가능한 링크드 리스트
  환형 링크드 리스트 : 마지막 노드에 첫 번쨰 노드(헤드)를 가리키는 포인터가 있어 마지막 요소에서 처음으로 이동 가능한 링크드 리스트


스택

  스택의 구조: 후입선출(LIFO)  
  push: 스택에 요소를 추가
  pop:스택에서 마지막 요소를 제거

큐
  스택의 구조 : 선입선출(FIFO)
  인큐 : 큐에 요소추가(뒷부분)
  디큐 : 큐에 요소 제거(앞부분)

배열
  .?

시간 복잡도 순서

  상수 시간<< 로그 시간<< 선형 시간 << 선형 로그 시간 << 다항시간(2차시간<3차시간) << 지수 시간
  
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

이진트리 

이진트리는 시간복잡도에서 평균이 로그 시간( O(log n)) 최악이 선형시간으로 해시테이블보다 속도가 느리지만, 배열과 같은 선형구조가 하기어려운 계층적 정보를 저장할 수 있음 (HTML, XML 도 트리로 표현가능)
  
  값이 노드의 값이 10,15,8,3,9,14라고 가정
  인오더
    def in_order(node):
      if node is None:
          return
      in_order(node.left)
      print(node.data, end="->")
      in_order(node.right)
    
    3-8-9-10-14-15  가장왼쪽자식 - 의 부모 - 의 오른쪽 자식 - 의 부모의 부모 - 의 자식의 왼쪽자식 - 의 부모    //가장 아래 계층의 왼쪽자식부터 왼자 - 부 - 오자 순서로
  프리오더
    def pre_order(node):
    if node is None:
        return
    print(node.data, end="->")
    pre_order(node.left)
    pre_order(node.right)

    3-8-9-14-15-10   10-8-3-9-15-14  부모 - 의 왼쪽 자식- 의 왼쪽 자식 - 오른쪽 자식 - 부모의 오른쪽 자식 - 의 오른쪽 자식 //아래 계층부터 확실하게 삭제하고 위로감 , 트리삭제나 메모리삭제시 깔끔하게 삭제하여 메모리누수방
  포스트오더  
    def post_order(node):
    if node: //if node is None:와 같은의미
        post_order(node.left)
        post_order(node.right)
        print(node.data, end='->')

   3-8-9-14-15-10 가장왼쪽자식 - 의 부모 - 의 오른쪽 자식 - 의 자식의 왼쪽자식 - 의 부모 - 의 부모    // 왼쪽 서브트리 순회-현재 노드(루트) 방문-오른쪽 서브트리 순회, 원소들이 오름차순으로 나온다는 특징이 있음.

  너비 우선 탐색

  깊이 우선 탐색
